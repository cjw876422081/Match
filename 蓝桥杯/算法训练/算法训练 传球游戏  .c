/*　【问题描述】
　　上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。
　　游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，
	每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，
		传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。
　　聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，
	传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。
	比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1->2->3->1和1->3->2->1，共2种。
输入格式
　　共一行，有两个用空格隔开的整数n，m（3<=n<=30，1<=m<=30）。
输出格式
　　t共一行，有一个整数，表示符合题意的方法数。
样例输入
3 3
样例输出
2
数据规模和约定
　　40%的数据满足：3<=n<=30，1<=m<=20
　　100%的数据满足：3<=n<=30，1<=m<=30
*/
#include<stdio.h>
void Output( int [][31] , int , int  ); 
int main(void)
{
	int n , m ;
	scanf("%d%d" , & n , & m ) ;
	int sz[31][31] ={ 0 } ; 
	Output( sz , n , m ) ; 
	return 0 ; 
 } 
 void Output( int sz[][31] , int n , int  m )
 {
 	int i , j ;
	sz[1][0] = 1  ;  
 	for( i = 1 ; i <= m ; i ++ )
 	{
 		sz[1][i] = sz[2][i-1] + sz[n][i-1] ;  
        sz[n][i] = sz[n-1][i-1] + sz[1][i-1];  
		for( j = 2 ; j < n ; j ++ )
 		{
 			 sz[j][i] = sz[j - 1][i - 1] + sz[j + 1][i - 1] ;
		}
	}
	printf("%d\n" , sz[1][m] ) ; 
 }
