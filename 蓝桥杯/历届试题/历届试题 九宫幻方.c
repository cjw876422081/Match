/*
问题描述
　　小明最近在教邻居家的小朋友小学奥数，而最近正好讲述到了三阶幻方这个部分，
三阶幻方指的是将1~9不重复的填入一个3*3的矩阵当中，使得每一行、每一列和每一条对角线的和都是相同的。
　　三阶幻方又被称作九宫格，在小学奥数里有一句非常有名的口诀：“二四为肩，六八为足，左三右七，戴九履一，五居其中”，
通过这样的一句口诀就能够非常完美的构造出一个九宫格来。
　　4 9 2
　　3 5 7
　　8 1 6
　　有意思的是，所有的三阶幻方，
	都可以通过这样一个九宫格进行若干镜像和旋转操作之后得到。
	现在小明准备将一个三阶幻方（不一定是上图中的那个）中的一些数抹掉，
	交给邻居家的小朋友来进行还原，并且希望她能够判断出究竟是不是只有一个解。
　　而你呢，也被小明交付了同样的任务，但是不同的是，你需要写一个程序~
输入格式
　　输入仅包含单组测试数据。
　　每组测试数据为一个3*3的矩阵，其中为0的部分表示被小明抹去的部分。
　　对于100%的数据，满足给出的矩阵至少能还原出一组可行的三阶幻方。
输出格式
　　如果仅能还原出一组可行的三阶幻方，则将其输出，否则输出“Too Many”（不包含引号）。
样例输入
0 7 2
0 5 0
0 3 0
样例输出
6 7 2
1 5 9
8 3 4
数据规模和约定
　　峰值内存消耗（含虚拟机） < 256M
　　CPU消耗 < 1000ms
　　请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。
　　注意：
　　main函数需要返回0;
　　只使用ANSI C/ANSI C++ 标准;
　　不要调用依赖于编译环境或操作系统的特殊函数。
　　所有依赖的函数必须明确地在源文件中 #include <xxx>
　　不能通过工程设置而省略常用头文件。
　　提交程序时，注意选择所期望的语言类型和编译器类型。
　　--------------
　　笨笨有话说：
　　我最喜欢这类题目了。既然九宫幻方一共也没有多少，我就不辞辛劳地一个一个写出来好了。
　　也不能太过分，好歹用个数组。
*/
#if 1 
#include<stdio.h>
void Input( int [][3] , int , char []); 
void panduan(  char [] , char [][9] , int *  ,int *sum ) ;
void Output( char [][9] , int ) ; 
int main(Void)
{
		char jg[8][9] ={ "492357816",  
	                   	 "834159672",  
	                   	 "618753294",  
	                   	 "276951438",  
	                   	 "294753618",  
	                   	 "816357492",  
	                  	 "438951276",  
	                   	 "672159834"};  
	int sz[3][3] , h  , sum  = 0 ;
	char zf[10] ;
	Input( sz ,  3 , zf ); 
	panduan(  zf  , jg , &h , &sum );
	if( sum == 1 )
	{
		Output( jg , h ) ; 
	}
	else
	{
		printf("Too Many\n") ; 
	}
	return 0 ; 
}
void Output( char jg[][9] , int n )
{
	int  i ;
	for(i = 0 ; i < 9 ; i += 3)
	{
    	printf("%c %c %c\n" ,jg[n][i] , jg[n][i+1], jg[n][i+2] );  
	}  
         
}
void panduan(  char zf[]  , char jg[][9] , int * zq , int *sum )
{

	int i , j , bj = 1 ; 
	for( i = 0 ; i < 8 ; i ++ )
	{
		for( j = 0 ; j < 9 ; j ++ )
		{
			if( zf[j] == '0' || zf[j] == jg[i][j] )  
            {  
                continue ;  
            } 
			else
			{
				if(zf[j] != jg[i][j])  
	            {  
	                bj = 0 ;  
	                break ;  
	        	}  
			}
		}
		if( bj == 1 )
		{  
            ++ *sum ;  
        	*zq = i ;  
        }
		else
		{  
            bj = 1 ;  
        }  
	}
	
	
}
void Input( int sz[][3] , int n , char zf[])
{
	int i , j , k = 0 ; 
	for( i = 0 ; i< n ; i ++ )
	{
		for( j = 0 ; j < n ; j ++ )
		{
			scanf("%d" , & sz[i][j]) ; 
			zf[k] = sz[i][j] + '0' ;  
			k ++ ; 
		}
	}
}
#endif 
